/**
 * 图算法翻译
 * @author changyadai
 */

export const graph = {
    // ===== Dijkstra最短路径 =====
    'Dijkstra最短路径可视化': "Dijkstra's Shortest Path Visualization",
    '单源最短路径的经典算法': 'Classic single-source shortest path algorithm',
    'Dijkstra算法用于在带权图中找到从源点到所有其他顶点的最短路径。它采用贪心策略，每次选择当前距离最小的未访问顶点进行扩展。': "Dijkstra's algorithm finds shortest paths from a source vertex to all other vertices in a weighted graph. It uses a greedy strategy, always expanding the unvisited vertex with minimum current distance.",
    '添加节点': 'Add Node',
    '添加边': 'Add Edge',
    '设置起点': 'Set Start',
    '距离表': 'Distance Table',
    '初始化：源点距离设为0，其他所有节点距离设为无穷大': 'Initialize: source distance = 0, all other nodes = infinity',
    '将源点加入优先队列（最小堆）': 'Add the source to a priority queue (min-heap)',
    '取出队列中距离最小的节点u': 'Extract the node u with the smallest distance from the queue',
    '对于u的每个邻居v，如果通过u到达v的距离更短，则更新v的距离': "For each neighbor v of u, if the path through u is shorter, update v's distance",
    '将更新后的邻居加入优先队列': 'Add the updated neighbor to the priority queue',
    '重复步骤3-5直到队列为空': 'Repeat steps 3-5 until the queue is empty',
    '关键洞察：已确定最短距离的节点不会再被更新，因为所有边权重非负。': "Key insight: Once a node's shortest distance is finalized, it won't be updated again because all edge weights are non-negative.",
    '时间与空间复杂度': 'Time & Space Complexity',
    '实现方式': 'Implementation',
    '数组实现': 'Array Implementation',
    '每次线性查找最小值': 'Linear search for minimum each time',
    '二叉堆': 'Binary Heap',
    '常用实现方式': 'Common implementation',
    '斐波那契堆': 'Fibonacci Heap',
    '理论最优但实现复杂': 'Theoretical best, complex implementation',
    '存储距离和优先队列': 'Store distances and priority queue',
    '注意：Dijkstra不能处理负权边。对于负权图，应使用Bellman-Ford算法。': 'Note: Dijkstra cannot handle negative edge weights. Use Bellman-Ford for graphs with negative edges.',
    'GPS导航系统的最短路线规划': 'GPS navigation shortest route planning',
    '网络路由协议（OSPF、IS-IS）': 'Network routing protocols (OSPF, IS-IS)',
    '社交网络中的最短关系链': 'Shortest relationship chain in social networks',
    '游戏中的NPC寻路': 'NPC pathfinding in games',
    '航班/铁路最优路线查询': 'Flight/railway optimal route queries',
    '导航系统': 'Navigation',
    '网络路由': 'Network Routing',
    '游戏开发': 'Game Dev',
    '路径规划': 'Path Planning',
    '单源最短路径算法': 'Single-source shortest path algorithm',

    // ===== BFS/DFS图遍历 =====
    'BFS与DFS图遍历可视化': 'BFS & DFS Graph Traversal Visualization',
    '广度优先 vs 深度优先搜索': 'Breadth-First vs Depth-First Search',
    'BFS（广度优先搜索）和DFS（深度优先搜索）是两种基本的图遍历算法。BFS使用队列，逐层扩展；DFS使用栈（或递归），尽可能深入探索。': 'BFS (Breadth-First Search) and DFS (Depth-First Search) are two fundamental graph traversal algorithms. BFS uses a queue, expanding layer by layer; DFS uses a stack (or recursion), exploring as deep as possible.',
    'BFS 广度优先': 'BFS Breadth-First',
    'DFS 深度优先': 'DFS Depth-First',
    '并行对比': 'Side by Side',
    'BFS (队列)': 'BFS (Queue)',
    'DFS (栈)': 'DFS (Stack)',
    '队列': 'Queue',
    '栈': 'Stack',
    '访问顺序': 'Visit Order',
    '算法对比': 'Algorithm Comparison',
    '数据结构': 'Data Structure',
    '队列 (FIFO)': 'Queue (FIFO)',
    '栈 (LIFO) / 递归': 'Stack (LIFO) / Recursion',
    '探索顺序': 'Exploration Order',
    '逐层扩展（由近及远）': 'Layer by layer (near to far)',
    '尽可能深入，再回溯': 'Go deep, then backtrack',
    '最短路径': 'Shortest Path',
    '保证找到（无权图）': 'Guaranteed (unweighted)',
    '不保证': 'Not guaranteed',
    '空间消耗': 'Space Usage',
    '可能较大（存储整层）': 'Can be large (stores entire layer)',
    '通常较小': 'Usually smaller',
    'V是顶点数，E是边数。两种算法时间复杂度相同，但实际空间使用取决于图的结构。': 'V is vertices, E is edges. Both have same time complexity, but actual space depends on graph structure.',
    'BFS适用于：': 'BFS is good for:',
    '无权图的最短路径': 'Shortest path in unweighted graphs',
    '社交网络中的"六度分隔"': '"Six degrees of separation" in social networks',
    '迷宫的最短路径': 'Shortest path in mazes',
    '网页爬虫': 'Web crawlers',
    'DFS适用于：': 'DFS is good for:',
    '拓扑排序': 'Topological sorting',
    '检测图中的环': 'Cycle detection',
    '寻找连通分量': 'Finding connected components',
    '解决迷宫问题（所有路径）': 'Maze solving (all paths)',
    '回溯算法': 'Backtracking algorithms',
    '连通性检测': 'Connectivity',
    '迷宫求解': 'Maze Solving',
    'BFS/DFS': 'BFS/DFS',
    '广度/深度优先遍历对比': 'Breadth/depth first traversal comparison',
    'BFS/DFS遍历': 'BFS/DFS Traversal',

    // ===== A*寻路算法 =====
    'A*寻路算法可视化': 'A* Pathfinding Visualization',
    '启发式最短路径搜索': 'Heuristic shortest path search',
    'A*算法是一种启发式搜索算法，结合了Dijkstra的最短路径保证和贪心搜索的效率。它使用估价函数 f(n) = g(n) + h(n) 来指导搜索方向。': "A* is a heuristic search algorithm combining Dijkstra's shortest path guarantee with greedy search efficiency. It uses evaluation function f(n) = g(n) + h(n) to guide the search direction.",
    '设置终点': 'Set End',
    '添加障碍': 'Add Obstacle',
    '清空网格': 'Clear Grid',
    'Open列表': 'Open List',
    'Closed列表': 'Closed List',
    'g(n)：从起点到节点n的实际代价': 'g(n): Actual cost from start to node n',
    'h(n)：从节点n到终点的启发式估计（如曼哈顿距离）': 'h(n): Heuristic estimate from n to goal (e.g., Manhattan distance)',
    'f(n) = g(n) + h(n)：节点n的总估价': 'f(n) = g(n) + h(n): Total evaluation of node n',
    '每次从Open列表中选择f值最小的节点扩展': 'Always expand node with smallest f value from Open list',
    '当选中的节点是终点时，搜索结束': 'Search ends when selected node is the goal',
    '启发函数h(n)必须是"可采纳的"（不高估实际代价），才能保证找到最短路径。': 'Heuristic h(n) must be "admissible" (never overestimate) to guarantee shortest path.',
    '最坏情况，取决于启发函数质量': 'Worst case, depends on heuristic quality',
    '实际性能': 'Actual Performance',
    '启发式引导减少探索节点': 'Heuristic guidance reduces nodes explored',
    '存储Open和Closed列表': 'Store Open and Closed lists',
    'A* vs Dijkstra：Dijkstra向所有方向均匀扩展，而A*优先向目标方向探索。': 'A* vs Dijkstra: Dijkstra expands uniformly in all directions, A* prioritizes toward the goal.',
    '游戏中的NPC寻路和单位移动': 'NPC pathfinding and unit movement in games',
    '机器人路径规划': 'Robot path planning',
    'GPS导航系统': 'GPS navigation systems',
    '自动驾驶路径决策': 'Autonomous driving path decisions',
    '物流配送路线优化': 'Logistics delivery route optimization',
    '机器人导航': 'Robot Navigation',
    '自动驾驶': 'Autonomous Driving',
    '物流优化': 'Logistics',
    '起点': 'Start',
    '终点': 'End',
    '障碍物': 'Obstacle',
    '待探索': 'Open',
    '已探索': 'Closed',
    '点击网格绘制/清除障碍物': 'Click grid to draw/clear obstacles',
    'A*寻路': 'A* Pathfinding',
    'A*寻路算法': 'A* Pathfinding',
    'A*启发式寻路算法': 'A* Heuristic Pathfinding Algorithm'
};
