/**
 * 排序算法翻译
 * @author changyadai
 */

export const sorting = {
    // ===== 冒泡排序 =====
    '冒泡排序可视化': 'Bubble Sort Visualization',
    '观察元素如何像气泡一样上浮到正确位置': 'Watch elements float up like bubbles to their correct positions',
    '冒泡排序（Bubble Sort）是一种简单直观的排序算法。它重复地遍历待排序的数列，一次比较两个相邻元素，如果顺序错误就把它们交换过来。每一轮遍历后，最大的元素会"浮"到数组末尾，就像水中的气泡上浮一样。': 'Bubble Sort is a simple and intuitive sorting algorithm. It repeatedly traverses the list, compares adjacent elements, and swaps them if they\'re in the wrong order. After each pass, the largest element "bubbles up" to the end, like bubbles rising in water.',
    '算法步骤': 'Algorithm Steps',
    '从数组的第一个元素开始，比较相邻的两个元素': 'Start from the first element, compare adjacent pairs',
    '如果前一个元素比后一个元素大，则交换它们的位置': 'If the left element is larger, swap their positions',
    '对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对': 'Do the same for every adjacent pair from start to end',
    '完成一轮后，最大的元素会排到最后': 'After one pass, the largest element is at the end',
    '重复以上步骤，每次比较范围减少一个（已排好的元素不再参与）': 'Repeat, reducing the comparison range each time',
    '当没有任何交换发生时，排序完成': 'Stop when no swaps occur in a pass',
    '数组已经有序，只需一次遍历': 'Array is already sorted, only one pass needed',
    '需要多次遍历和交换': 'Multiple passes and swaps required',
    '数组完全逆序': 'Array is in reverse order',
    '只需常数级额外空间（原地排序）': 'Only constant extra space needed (in-place)',
    '冒泡排序是<strong>稳定排序</strong>，相等元素的相对顺序不会改变。': 'Bubble Sort is a <strong>stable sort</strong>, preserving the relative order of equal elements.',
    '冒泡排序是': 'Bubble Sort is a ',
    '，相等元素的相对顺序不会改变。': ', preserving the relative order of equal elements.',
    '适用场景': 'Use Cases',
    '教学演示：作为最简单的排序算法之一，非常适合算法入门学习': 'Teaching: As one of the simplest algorithms, great for beginners',
    '小规模数据：当数据量很小时（n < 50），简单实现的优势明显': 'Small datasets: When n < 50, simple implementation wins',
    '几乎有序的数组：如果数组大部分已经有序，冒泡排序效率较高': 'Nearly sorted arrays: Efficient when data is almost sorted',
    '需要稳定性：当需要保持相等元素的原始顺序时': 'Stability required: When preserving original order matters',
    '算法教学': 'Education',
    '小数据集': 'Small Data',
    '稳定排序需求': 'Stable Sorting',
    '小规模数据': 'Small-scale Data',
    '当数据量很小时': 'When data size is small',
    '简单实现的优势明显': 'simple implementation has clear advantages',
    '小规模数据：当数据量很小时（n &lt; 50），简单实现的优势明显': 'Small-scale Data: When data size is small (n < 50), simple implementation has clear advantages',
    '冒泡排序': 'Bubble Sort',
    '相邻元素两两比较，较大元素上浮': 'Compare adjacent elements, larger floats up',

    // ===== 堆排序 =====
    '堆排序可视化': 'Heap Sort Visualization',
    '观察二叉堆的构建与调整过程': 'Watch the binary heap construction and adjustment process',
    '堆排序（Heap Sort）利用二叉堆这种数据结构来实现排序。它首先将数组构建成一个最大堆，然后不断取出堆顶元素（最大值）放到数组末尾，同时调整剩余元素保持堆的性质。': 'Heap Sort uses the binary heap data structure for sorting. It first builds a max-heap from the array, then repeatedly extracts the maximum element (root) to the end while maintaining the heap property.',
    '堆排序（Heap Sort）是一种利用堆数据结构设计的排序算法。它首先将数组构建成一个最大堆（父节点总是大于子节点），然后不断取出堆顶的最大元素，放到数组末尾，同时调整剩余元素重新形成堆，直到所有元素都被取出。': 'Heap Sort is a sorting algorithm that uses the heap data structure. It first builds a max-heap from the array (where parent nodes are always larger than children), then repeatedly extracts the maximum element from the top, places it at the end of the array, and adjusts the remaining elements to reform the heap, until all elements are extracted.',
    '将待排序数组构建成一个最大堆（Build Max-Heap）': 'Build a max-heap from the array (Build Max-Heap)',
    '此时堆顶元素（arr[0]）为最大值': 'The root element (arr[0]) is now the maximum',
    '将堆顶元素与最后一个元素交换': 'Swap root with the last element',
    '堆大小减1，对新的堆顶执行下沉操作（Heapify）': 'Reduce heap size by 1, heapify the new root',
    '重复步骤3-4，直到堆大小为1': 'Repeat steps 3-4 until heap size is 1',
    '建堆': 'Build Heap',
    '自底向上建堆的时间复杂度': 'Bottom-up heap construction complexity',
    '排序（所有情况）': 'Sort (All Cases)',
    '每次取出堆顶需要O(log n)调整': 'O(log n) adjustment per extraction',
    '原地排序，只需常数额外空间': 'In-place sorting, only constant extra space',
    '堆排序是<strong>不稳定排序</strong>，相等元素的相对顺序可能改变。': 'Heap Sort is an <strong>unstable sort</strong>, relative order of equal elements may change.',
    '需要原地排序且保证O(n log n)最坏情况性能': 'Need in-place sorting with guaranteed O(n log n) worst case',
    '实现优先队列数据结构': 'Implementing priority queue data structures',
    '找出数组中前K大/小的元素': 'Finding top K largest/smallest elements',
    '系统调度、任务优先级管理': 'System scheduling and task priority management',
    '优先队列': 'Priority Queue',
    'Top-K问题': 'Top-K Problem',
    '任务调度': 'Task Scheduling',
    '内存受限场景': 'Memory-Constrained',
    '数组视图': 'Array View',
    '堆排序': 'Heap Sort',
    '利用二叉堆特性完成排序': 'Uses binary heap properties for sorting',

    // ===== 快速排序 =====
    '快速排序可视化': 'Quick Sort Visualization',
    '观察分治策略与基准元素的分区过程': 'Watch the divide-and-conquer partitioning process',
    '快速排序（Quick Sort）是一种高效的分治排序算法。它选择一个"基准"元素，将数组分成两部分：小于基准的在左边，大于基准的在右边，然后递归地对两部分进行排序。': 'Quick Sort is an efficient divide-and-conquer algorithm. It selects a "pivot" element and partitions the array: elements smaller than pivot go left, larger go right. Then recursively sort both parts.',
    '快速排序（Quick Sort）是一种高效的分治排序算法。它选择一个"基准"元素，将数组分成两部分：比基准小的元素放在左边，比基准大的元素放在右边。然后递归地对左右两部分继续排序。因其出色的平均性能，快速排序是实际应用中最常用的排序算法之一。': 'Quick Sort is an efficient divide-and-conquer sorting algorithm. It selects a "pivot" element and partitions the array into two parts: elements smaller than the pivot go to the left, larger ones to the right. Then recursively sorts both parts. Due to its excellent average performance, Quick Sort is one of the most commonly used sorting algorithms in practice.',
    '选择一个元素作为"基准"（pivot），通常选择最后一个元素': 'Choose a pivot element (usually the last element)',
    '设置两个指针：i（小于基准区域的边界）和j（扫描指针）': 'Set two pointers: i (boundary of smaller section) and j (scanner)',
    'j从左向右扫描，遇到小于基准的元素就与i+1位置交换，i右移': 'j scans left to right; swap elements smaller than pivot with i+1, increment i',
    '扫描完成后，将基准与i+1位置交换，此时基准就位': 'After scanning, swap pivot with position i+1; pivot is now in place',
    '递归地对基准左右两部分执行相同操作': 'Recursively apply to left and right partitions',
    '每次分区都能平均分割数组': 'Each partition splits array evenly',
    '随机输入的期望性能': 'Expected performance on random input',
    '每次选到最大或最小元素作为基准': 'Always picking smallest or largest as pivot',
    '递归调用栈的深度': 'Recursive call stack depth',
    '快速排序是<strong>不稳定排序</strong>，但可以通过三路划分等变体来优化。': 'Quick Sort is <strong>unstable</strong>, but can be optimized with three-way partitioning.',
    '通用排序：大多数编程语言标准库的排序函数都基于快速排序': 'General sorting: Most language standard libraries use Quick Sort',
    '大规模数据排序：平均性能优秀，缓存命中率高': 'Large-scale data: Excellent average performance, good cache locality',
    '不需要稳定性的场景：如数值排序': 'When stability not required: e.g., numerical sorting',
    '可以结合其他算法：小数组使用插入排序优化': 'Hybrid approaches: Use insertion sort for small arrays',
    '通用排序': 'General Sorting',
    '大数据集': 'Large Data',
    '系统库实现': 'Standard Library',
    '竞赛算法': 'Competitive Programming',
    '基准元素': 'Pivot',
    '左指针': 'Left Pointer',
    '右指针': 'Right Pointer',
    '递归深度:': 'Recursion Depth:',
    '递归深度': 'Recursion Depth',
    '快速排序': 'Quick Sort',
    '分治策略，基准元素分区': 'Divide and conquer with pivot partitioning',

    // ===== 归并排序 =====
    '归并排序可视化': 'Merge Sort Visualization',
    '观察分解与合并的递归过程': 'Watch the recursive divide and merge process',
    '观察分治策略的分解与合并过程': 'Watch the divide-and-conquer decomposition and merging process',
    '归并排序（Merge Sort）是一种稳定的分治排序算法。它将数组递归地分成两半，分别排序后再合并。核心思想是：将两个有序数组合并成一个有序数组是高效的。': 'Merge Sort is a stable divide-and-conquer algorithm. It recursively splits the array in half, sorts each half, then merges them. The key insight: merging two sorted arrays into one is efficient.',
    '归并排序（Merge Sort）是一种基于分治思想的稳定排序算法。它将数组不断二分直到每个子数组只有一个元素，然后自底向上地将相邻的有序子数组合并成更大的有序数组。归并排序在任何情况下都能保证O(n log n)的时间复杂度。': 'Merge Sort is a stable sorting algorithm based on the divide-and-conquer principle. It repeatedly splits the array in half until each subarray has only one element, then bottom-up merges adjacent sorted subarrays into larger sorted arrays. Merge Sort guarantees O(n log n) time complexity in all cases.',
    '将数组从中间分成两个子数组': 'Split the array into two halves at the middle',
    '对左右两个子数组分别进行归并排序': 'Recursively merge sort both halves',
    '将两个有序的子数组合并成一个有序数组': 'Merge the two sorted halves into one sorted array',
    '合并操作是关键：使用两个指针分别指向左右子数组的起始位置，每次比较后将较小的元素放入结果数组，直到所有元素都被处理完毕。': 'The merge operation is key: use two pointers at the start of each subarray, compare and add the smaller element to the result, until all elements are processed.',
    '所有情况': 'All Cases',
    '无论输入如何，时间复杂度都相同': 'Time complexity is the same regardless of input',
    '需要额外数组存储合并结果': 'Extra array needed for merging',
    '归并排序是<strong>稳定排序</strong>，相等元素的相对顺序保持不变。这是其相比快速排序的重要优势。': 'Merge Sort is a <strong>stable sort</strong>, preserving relative order of equal elements. This is a major advantage over Quick Sort.',
    '需要稳定排序：如按多个字段排序时保持次要字段顺序': 'Stable sorting: When secondary key order must be preserved',
    '链表排序：归并排序对链表特别高效，不需要额外空间': 'Linked list sorting: Very efficient, no extra space needed',
    '外部排序：处理无法一次载入内存的大数据': 'External sorting: Processing data too large for memory',
    '需要保证最坏情况性能：时间复杂度恒为O(n log n)': 'Guaranteed worst-case performance: Always O(n log n)',
    '稳定排序': 'Stable Sort',
    '链表排序': 'Linked Lists',
    '外部排序': 'External Sort',
    '大数据处理': 'Big Data',
    '当前操作': 'Current Operation',
    '左子数组': 'Left Array',
    '右子数组': 'Right Array',
    '合并结果': 'Merge Result',
    '数组状态': 'Array State',
    '分解': 'Divide',
    '合并': 'Merge',
    '归并排序': 'Merge Sort',
    '分解子数组后合并': 'Divide into subarrays then merge'
};
