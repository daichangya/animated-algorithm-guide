/**
 * 搜索与优化算法翻译
 * @author changyadai
 */

export const search = {
    // ===== 二分查找 =====
    '二分查找可视化': 'Binary Search Visualization',
    '有序数组中的高效查找': 'Efficient search in sorted arrays',
    '二分查找（Binary Search）是一种在有序数组中查找特定元素的算法。每次比较都能将搜索范围缩小一半，因此效率极高，时间复杂度为O(log n)。': 'Binary Search finds a specific element in a sorted array. Each comparison halves the search range, achieving O(log n) time complexity.',
    '查找目标': 'Search Target',
    '查找目标:': 'Search Target:',
    '输入要查找的数字': 'Enter number to find',
    'L': 'L',
    'M': 'M',
    'R': 'R',
    '找到！': 'Found!',
    '未找到': 'Not Found',
    'Mid值': 'Mid Value',
    '目标': 'Target',
    '初始化左指针left=0，右指针right=n-1': 'Initialize left pointer = 0, right pointer = n-1',
    '计算中间位置 mid = (left + right) / 2': 'Calculate middle position mid = (left + right) / 2',
    '比较 arr[mid] 与目标值：': 'Compare arr[mid] with target:',
    '相等：找到目标，返回mid': 'Equal: Found target, return mid',
    'arr[mid] > target：目标在左半部分，right = mid - 1': 'arr[mid] > target: Target in left half, right = mid - 1',
    'arr[mid] < target：目标在右半部分，left = mid + 1': 'arr[mid] < target: Target in right half, left = mid + 1',
    'arr[mid] &lt; target：目标在右半部分，left = mid + 1': 'arr[mid] < target: Target in right half, left = mid + 1',
    '重复步骤2-3，直到 left > right（未找到）': 'Repeat 2-3 until left > right (not found)',
    '目标恰好在中间': 'Target is exactly in the middle',
    '每次搜索范围减半': 'Search range halves each time',
    '只需常数额外空间': 'Only constant extra space',
    '为什么是O(log n)？因为每次比较后范围减半，最多需要 log₂(n) 次比较。对于100万个元素，最多只需约20次比较！': 'Why O(log n)? Range halves after each comparison, at most log₂(n) comparisons needed. For 1 million elements, only ~20 comparisons!',
    '在有序数组/列表中查找元素': 'Finding elements in sorted arrays/lists',
    '数据库索引查询（B树、B+树）': 'Database index queries (B-tree, B+tree)',
    '查找插入位置（如bisect模块）': 'Finding insertion positions (like bisect)',
    '求解单调函数的零点': 'Finding roots of monotonic functions',
    '算法竞赛中的"二分答案"技巧': '"Binary search the answer" in competitive programming',
    '有序查找': 'Sorted Search',
    '数据库索引': 'Database Index',
    '二分答案': 'Binary Answer',
    '数值计算': 'Numerical Methods',
    '范围: 1-100': 'Range: 1-100',
    '步骤:': 'Step:',
    '二分查找': 'Binary Search',

    // ===== 0/1背包问题 =====
    '0/1背包问题可视化': '0/1 Knapsack Problem Visualization',
    '动态规划经典优化问题': 'Classic dynamic programming optimization problem',
    '重量': 'Weight',
    '价值': 'Value',
    '重量:': 'Weight:',
    '价值:': 'Value:',
    '0/1背包问题是一个经典的组合优化问题：给定n个物品（每个有重量和价值）和一个容量为W的背包，如何选择物品使得总价值最大，同时不超过背包容量？': "The 0/1 Knapsack is a classic combinatorial optimization problem: given n items (each with weight and value) and a knapsack of capacity W, how to select items to maximize total value without exceeding capacity?",
    '背包容量': 'Knapsack Capacity',
    '物品列表': 'Item List',
    'DP表格': 'DP Table',
    '物品': 'Item',
    '不选': 'skip ',
    '选': 'take ',
    '回溯找出选中的物品...': 'Backtracking to find selected items...',
    '最大价值': 'Maximum Value',
    '选中物品': 'Selected Items',
    '设 dp[i][w] 表示考虑前i个物品、容量为w时的最大价值。': 'Let dp[i][w] represent max value considering first i items with capacity w.',
    '不选第i个物品：dp[i][w] = dp[i-1][w]': "Don't take item i: dp[i][w] = dp[i-1][w]",
    '选第i个物品（需要能装下）：dp[i][w] = dp[i-1][w-wi] + vi': 'Take item i (if it fits): dp[i][w] = dp[i-1][w-wi] + vi',
    '取两者最大值': 'Take the maximum of both',
    'N是物品数，W是容量': 'N is items, W is capacity',
    '存储DP表格': 'Store DP table',
    '使用一维数组，逆序遍历': '1D array with reverse iteration',
    '注意：这是伪多项式时间，因为W可能很大。当W以二进制表示时，算法是指数级的。': 'Note: This is pseudo-polynomial time because W can be large. When W is represented in binary, algorithm is exponential.',
    '资源分配问题（预算分配）': 'Resource allocation (budget allocation)',
    '货物装载优化': 'Cargo loading optimization',
    '投资组合选择': 'Investment portfolio selection',
    '文件选择备份（磁盘空间限制）': 'File backup selection (disk space limit)',
    '密码学中的子集和问题': 'Subset sum problem in cryptography',
    '资源分配': 'Resource Allocation',
    '货运优化': 'Cargo Optimization',
    '投资决策': 'Investment',
    '组合优化': 'Combinatorial Optimization',
    '动态规划状态定义': 'DP State Definition',
    '物品列表 (容量:': 'Item List (Capacity:',
    '0/1背包': '0/1 Knapsack',
    '0/1 Knapsack问题': '0/1 Knapsack Problem',
    '0/1背包问题': '0/1 Knapsack Problem',

    // ===== 物品名称（背包问题）=====
    '宝石': 'Gem',
    '金币': 'Gold Coin',
    '王冠': 'Crown',
    '药水': 'Potion',
    '卷轴': 'Scroll'
};
