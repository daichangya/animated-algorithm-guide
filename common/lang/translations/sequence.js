/**
 * 字符串/序列算法翻译
 * @author changyadai
 */

export const sequence = {
    // ===== Myers差异算法 =====
    'Myers差异算法可视化': 'Myers Diff Algorithm Visualization',
    'Git Diff 的核心算法 - 最小编辑距离': 'The core algorithm behind Git Diff - Minimum Edit Distance',
    'Myers差异算法是Git等版本控制系统的核心。它能找出两个序列之间的最小编辑操作（插入和删除），通过在编辑图上寻找最短路径来实现。': 'Myers diff algorithm is the core of Git and other version control systems. It finds the minimum edit operations (insertions and deletions) between two sequences by finding the shortest path on an edit graph.',
    'Myers差异算法是由Eugene W. Myers在1986年提出的，用于计算两个序列之间的最小编辑距离。它是Git diff、GNU diff等工具的核心算法。该算法通过在"编辑图"上搜索从左上角到右下角的最短路径来找出差异，每次向右移动表示删除，向下移动表示插入，对角线移动表示匹配。': 'The Myers diff algorithm was proposed by Eugene W. Myers in 1986 for computing the minimum edit distance between two sequences. It is the core algorithm of Git diff, GNU diff, and other tools. The algorithm finds differences by searching for the shortest path from the top-left to the bottom-right corner on an "edit graph", where moving right represents deletion, moving down represents insertion, and diagonal moves represent matches.',
    '源序列 (A)': 'Source Sequence (A)',
    '目标序列 (B)': 'Target Sequence (B)',
    '源序列': 'Source Sequence',
    '目标序列': 'Target Sequence',
    '输入源序列': 'Enter source sequence',
    '输入目标序列': 'Enter target sequence',
    '源:': 'Source:',
    '目标:': 'Target:',
    '编辑图 (Edit Graph)': 'Edit Graph',
    '编辑图': 'Edit Graph',
    '差异结果': 'Diff Result',
    '编辑距离 D =': 'Edit Distance D =',
    '字符模式': 'Character Mode',
    '行模式': 'Line Mode',
    '算法原理': 'Algorithm Principle',
    '构建编辑图：X轴代表源序列，Y轴代表目标序列': 'Build edit graph: X-axis represents source, Y-axis represents target',
    '水平移动 = 删除源序列字符，垂直移动 = 插入目标序列字符': 'Horizontal move = delete from source, Vertical move = insert from target',
    '对角线移动 = 字符匹配（免费）': 'Diagonal move = character match (free)',
    '目标：找到从(0,0)到(N,M)的最短路径': 'Goal: Find shortest path from (0,0) to (N,M)',
    '使用D值（编辑距离）逐层搜索，找到最小D的路径': 'Search layer by layer with increasing D (edit distance)',
    '算法从D=0开始，逐步增加D值，直到找到一条从(0,0)到(N,M)的路径。这保证了找到的是最短编辑路径。': 'Algorithm starts with D=0, incrementally increasing D until finding a path from (0,0) to (N,M). This guarantees finding the shortest edit path.',
    'D是编辑距离，最坏情况D=N+M': 'D is edit distance, worst case D=N+M',
    '两个完全不同的序列': 'Two completely different sequences',
    '只需存储当前和前一行的状态': 'Only need current and previous row states',
    '在实际应用中，大多数差异较小，因此平均性能非常好。': 'In practice, most differences are small, so average performance is excellent.',
    '应用场景': 'Applications',
    'Git版本控制系统的diff功能': 'Git version control diff functionality',
    'GNU diff工具': 'GNU diff tool',
    '代码审查工具的变更对比': 'Code review change comparison',
    '文档比较和合并工具': 'Document comparison and merge tools',
    'DNA序列比对（生物信息学）': 'DNA sequence alignment (bioinformatics)',
    'Git Diff': 'Git Diff',
    '版本控制': 'Version Control',
    '代码审查': 'Code Review',
    '文档对比': 'Document Comparison',
    'Myers差异': 'Myers Diff',
    '最小编辑距离，Git diff核心': 'Minimum edit distance, Git diff core',

    // ===== LCS最长公共子序列 =====
    '最长公共子序列可视化': 'Longest Common Subsequence Visualization',
    '动态规划经典问题 - LCS': 'Classic Dynamic Programming Problem - LCS',
    '最长公共子序列（LCS）问题是寻找两个序列共有的最长子序列。子序列不要求连续，但必须保持相对顺序。LCS是许多文本比较和生物信息学应用的基础。': 'The Longest Common Subsequence (LCS) problem finds the longest subsequence common to two sequences. Subsequences don\'t need to be contiguous but must maintain relative order. LCS is fundamental to text comparison and bioinformatics.',
    '序列 A': 'Sequence A',
    '序列 B': 'Sequence B',
    '序列A': 'Sequence A',
    '序列B': 'Sequence B',
    '输入序列A': 'Enter sequence A',
    '输入序列B': 'Enter sequence B',
    'A:': 'A:',
    'B:': 'B:',
    'DP 矩阵': 'DP Matrix',
    'DP矩阵': 'DP Matrix',
    '最长公共子序列': 'Longest Common Subsequence',
    '动态规划思路': 'Dynamic Programming Approach',
    '设 dp[i][j] 表示序列A的前i个字符与序列B的前j个字符的LCS长度。': 'Let dp[i][j] represent the LCS length of first i chars of A and first j chars of B.',
    '如果 A[i-1] == B[j-1]：dp[i][j] = dp[i-1][j-1] + 1（当前字符匹配，LCS长度+1）': 'If A[i-1] == B[j-1]: dp[i][j] = dp[i-1][j-1] + 1 (match, LCS length +1)',
    '如果 A[i-1] != B[j-1]：dp[i][j] = max(dp[i-1][j], dp[i][j-1])（取左边或上边的较大值）': 'If A[i-1] != B[j-1]: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) (take max of left/top)',
    '最终 dp[m][n] 就是LCS的长度。通过回溯DP表可以还原出具体的LCS序列。': 'dp[m][n] is the LCS length. Backtrack through the DP table to reconstruct the actual LCS.',
    '需要填充整个DP表': 'Need to fill entire DP table',
    '需要存储DP表': 'Need to store DP table',
    '只存储两行即可（如果只需长度）': 'Store only two rows (if only length needed)',
    '文本比较：diff工具比较文件差异': 'Text comparison: diff tools for file comparison',
    '生物信息学：DNA/蛋白质序列比对': 'Bioinformatics: DNA/protein sequence alignment',
    '版本控制：检测代码变更': 'Version control: Detecting code changes',
    '拼写检查：计算编辑距离的基础': 'Spell checking: Basis for edit distance',
    '数据去重：识别相似内容': 'Data deduplication: Identifying similar content',
    '文本比较': 'Text Comparison',
    'DNA比对': 'DNA Alignment',
    '相似度计算': 'Similarity',
    'LCS公共子序列': 'LCS Subsequence',
    '动态规划找最长公共子序列': 'DP for longest common subsequence',

    // ===== KMP字符串匹配 =====
    'KMP字符串匹配可视化': 'KMP String Matching Visualization',
    '利用前缀表跳过无效比较': 'Skip unnecessary comparisons using the prefix table',
    'KMP（Knuth-Morris-Pratt）算法是一种高效的字符串匹配算法。它利用已匹配部分的信息，避免从头开始重新匹配，通过"前缀表"（也叫next数组）实现O(n+m)的时间复杂度。': 'KMP (Knuth-Morris-Pratt) is an efficient string matching algorithm. It uses information from previous matches to avoid restarting from scratch, achieving O(n+m) time complexity through the "prefix table" (or next array).',
    '文本串': 'Text String',
    '模式串': 'Pattern String',
    '输入文本串': 'Enter text string',
    '输入模式串': 'Enter pattern string',
    '前缀表 (Next数组)': 'Prefix Table (Next Array)',
    '前缀表': 'Prefix Table',
    '匹配过程': 'Matching Process',
    '匹配结果': 'Match Result',
    '匹配位置': 'Match Position',
    '核心概念': 'Core Concepts',
    '前缀表记录模式串每个位置的"最长相等前后缀"长度': 'Prefix table records "longest proper prefix which is also suffix" for each position',
    '当匹配失败时，利用前缀表跳过已知不可能匹配的位置': 'On mismatch, use prefix table to skip positions that can\'t possibly match',
    '模式串不需要回退到起点，而是跳到前缀表指示的位置': 'Pattern doesn\'t restart from beginning, jumps to position indicated by prefix table',
    '例如 "ABAB" 的最长相等前后缀是 "AB"，长度为2。': 'Example: "ABAB" has longest proper prefix-suffix "AB", length 2.',
    '构建前缀表': 'Build Prefix Table',
    'M是模式串长度': 'M is pattern length',
    '匹配阶段': 'Matching Phase',
    'N是文本串长度': 'N is text length',
    '总时间': 'Total Time',
    '远优于朴素算法的O(N×M)': 'Much better than naive O(N×M)',
    '存储前缀表': 'Store prefix table',
    '文本编辑器的查找功能': 'Text editor find functionality',
    '搜索引擎的关键词匹配': 'Search engine keyword matching',
    'DNA序列模式搜索': 'DNA sequence pattern search',
    '网络入侵检测（特征码匹配）': 'Network intrusion detection (signature matching)',
    '数据压缩算法': 'Data compression algorithms',
    '文本搜索': 'Text Search',
    '模式匹配': 'Pattern Matching',
    '生物信息学': 'Bioinformatics',
    '网络安全': 'Network Security',
    'KMP匹配': 'KMP Matching',
    '前缀表加速字符串匹配': 'Prefix table accelerates string matching'
};
