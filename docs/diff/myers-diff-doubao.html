<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Myers差异算法 - k线动画演示</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">

    <!-- 配置Tailwind自定义颜色和字体 -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#3B82F6',
                        secondary: '#10B981',
                        accent: '#8B5CF6',
                        neutral: '#1F2937',
                        'k-line': '#EF4444',
                        'grid-line': '#E5E7EB',
                        'path-color': '#F59E0B',
                    },
                    fontFamily: {
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                    },
                }
            }
        }
    </script>

    <style type="text/tailwindcss">
        @layer utilities {
            .content-auto {
                content-visibility: auto;
            }
            .grid-bg {
                background-size: 40px 40px;
                background-image:
                    linear-gradient(to right, theme('colors.grid-line') 1px, transparent 1px),
                    linear-gradient(to bottom, theme('colors.grid-line') 1px, transparent 1px);
            }
            .k-line {
                stroke: theme('colors.k-line');
                stroke-width: 2;
                stroke-dasharray: 5,5;
                opacity: 0.7;
            }
            .path-line {
                stroke: theme('colors.path-color');
                stroke-width: 3;
                fill: none;
            }
            .path-point {
                fill: theme('colors.path-color');
                r: 6;
            }
            .sequence-item {
                @apply w-10 h-10 flex items-center justify-center text-center font-medium rounded border;
            }
            .control-btn {
                @apply px-4 py-2 rounded-lg transition-all duration-200 flex items-center gap-2;
            }
            .control-btn-primary {
                @apply bg-primary text-white hover:bg-primary/90 active:bg-primary/80;
            }
            .control-btn-secondary {
                @apply bg-gray-200 text-gray-800 hover:bg-gray-300 active:bg-gray-400;
            }
        }
    </style>
</head>
<body class="bg-gray-50 font-sans text-neutral">
    <div class="container mx-auto px-4 py-8 max-w-6xl">
        <!-- 标题区域 -->
        <header class="mb-8 text-center">
            <h1 class="text-[clamp(1.8rem,4vw,2.5rem)] font-bold text-neutral mb-2">Myers差异算法</h1>
            <p class="text-gray-600 text-lg">k线概念与最短路径搜索动画演示</p>
        </header>

        <!-- 控制面板 -->
        <div class="bg-white rounded-xl shadow-md p-4 mb-6 flex flex-wrap gap-4 items-center justify-between">
            <div class="flex flex-wrap gap-3">
                <button id="startBtn" class="control-btn control-btn-primary">
                    <i class="fa fa-play"></i> 开始动画
                </button>
                <button id="pauseBtn" class="control-btn control-btn-secondary hidden">
                    <i class="fa fa-pause"></i> 暂停
                </button>
                <button id="resetBtn" class="control-btn control-btn-secondary">
                    <i class="fa fa-refresh"></i> 重置
                </button>
                <button id="speedBtn" class="control-btn control-btn-secondary">
                    <i class="fa fa-tachometer"></i> 速度: <span id="speedText">中等</span>
                </button>
            </div>

            <div class="flex items-center gap-2">
                <label for="speedRange" class="text-sm text-gray-600">动画速度:</label>
                <input type="range" id="speedRange" min="50" max="2000" value="800" step="50"
                       class="w-32 accent-primary">
            </div>
        </div>

        <!-- 主要演示区域 -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-8">
            <!-- 左侧序列 -->
            <div class="lg:col-span-1">
                <div class="bg-white rounded-xl shadow-md p-5 h-full">
                    <h2 class="text-xl font-semibold mb-4 flex items-center">
                        <i class="fa fa-code text-primary mr-2"></i> 序列 A (x轴)
                    </h2>
                    <div id="sequenceA" class="flex flex-wrap gap-2 mb-4">
                        <!-- 序列A元素将通过JS动态生成 -->
                    </div>

                    <h2 class="text-xl font-semibold mb-4 mt-6 flex items-center">
                        <i class="fa fa-info-circle text-accent mr-2"></i> 算法说明
                    </h2>
                    <div class="text-sm text-gray-600 space-y-2">
                        <p>Myers差异算法通过寻找两个序列的最短编辑路径，计算出最少的插入、删除操作。</p>
                        <p><span class="font-medium text-k-line">k线</span> 定义为满足 k = x - y 的所有点(x,y)，代表插入和删除操作的平衡状态。</p>
                        <p>动画展示了算法如何沿着k线寻找最优路径。</p>
                    </div>
                </div>
            </div>

            <!-- 中间动画区域 -->
            <div class="lg:col-span-2">
                <div class="bg-white rounded-xl shadow-md p-5 h-full">
                    <h2 class="text-xl font-semibold mb-4 flex items-center">
                        <i class="fa fa-area-chart text-k-line mr-2"></i> k线与路径动画
                    </h2>

                    <!-- 图例 -->
                    <div class="flex flex-wrap gap-4 mb-4 text-sm">
                        <div class="flex items-center">
                            <div class="w-4 h-4 bg-k-line/30 border border-k-line rounded-sm mr-2"></div>
                            <span>k线 (k = x - y)</span>
                        </div>
                        <div class="flex items-center">
                            <div class="w-4 h-4 bg-path-color rounded-full mr-2"></div>
                            <span>搜索路径</span>
                        </div>
                        <div class="flex items-center">
                            <div class="w-4 h-4 bg-primary rounded-sm mr-2"></div>
                            <span>匹配点</span>
                        </div>
                    </div>

                    <!-- 动画画布容器 -->
                    <div class="relative overflow-auto" style="height: 500px;">
                        <div id="animationContainer" class="relative grid-bg" style="width: 800px; height: 800px; padding: 40px;">
                            <!-- SVG元素将通过JS动态生成 -->
                            <svg id="animationSvg" class="absolute top-0 left-0 w-full h-full" viewBox="0 0 800 800">
                                <!-- k线和路径将通过JS动态绘制 -->
                            </svg>

                            <!-- 坐标轴标签将通过JS动态生成 -->
                            <div id="xAxisLabels" class="absolute bottom-0 left-40 flex flex-col items-center">
                                <!-- X轴标签 -->
                            </div>
                            <div id="yAxisLabels" class="absolute top-40 left-0 flex flex-col items-center">
                                <!-- Y轴标签 -->
                            </div>
                        </div>
                    </div>

                    <!-- 当前步骤信息 -->
                    <div class="mt-4 p-3 bg-gray-50 rounded-lg border border-gray-200">
                        <h3 class="font-medium mb-1">当前状态</h3>
                        <p id="currentStatus" class="text-sm text-gray-600">准备就绪，点击"开始动画"按钮开始演示</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- 右侧序列 -->
        <div class="bg-white rounded-xl shadow-md p-5 mb-8">
            <h2 class="text-xl font-semibold mb-4 flex items-center">
                <i class="fa fa-code-fork text-secondary mr-2"></i> 序列 B (y轴)
            </h2>
            <div id="sequenceB" class="flex flex-wrap gap-2">
                <!-- 序列B元素将通过JS动态生成 -->
            </div>
        </div>

        <!-- 页脚 -->
        <footer class="text-center text-gray-500 text-sm py-4">
            <p>Myers差异算法动画演示 | k线概念可视化</p>
        </footer>
    </div>

    <script>
        // 配置参数
        const config = {
            cellSize: 40,          // 每个单元格大小
            startOffset: 40,       // 起始偏移量
            animationSpeed: 800,   // 动画速度(毫秒)
            sequenceA: ['A', 'B', 'C', 'A', 'D', 'B'],  // 第一个序列
            sequenceB: ['A', 'C', 'A', 'B', 'E']        // 第二个序列
        };

        // 动画状态
        const state = {
            isAnimating: false,
            isPaused: false,
            currentStep: 0,
            path: [],          // 存储路径点
            kLines: [],        // 存储k线信息
            animationFrame: null,
            speedLevel: '中等'
        };

        // DOM元素
        const elements = {
            startBtn: document.getElementById('startBtn'),
            pauseBtn: document.getElementById('pauseBtn'),
            resetBtn: document.getElementById('resetBtn'),
            speedBtn: document.getElementById('speedBtn'),
            speedRange: document.getElementById('speedRange'),
            speedText: document.getElementById('speedText'),
            currentStatus: document.getElementById('currentStatus'),
            sequenceA: document.getElementById('sequenceA'),
            sequenceB: document.getElementById('sequenceB'),
            animationSvg: document.getElementById('animationSvg'),
            xAxisLabels: document.getElementById('xAxisLabels'),
            yAxisLabels: document.getElementById('yAxisLabels')
        };

        // 初始化页面
        function init() {
            // 渲染序列
            renderSequence(elements.sequenceA, config.sequenceA, 'bg-blue-50 text-primary border-primary/30');
            renderSequence(elements.sequenceB, config.sequenceB, 'bg-green-50 text-secondary border-secondary/30');

            // 生成坐标轴标签
            generateAxisLabels();

            // 预计算k线
            precomputeKLines();

            // 绘制初始k线
            drawKLines();

            // 添加事件监听
            elements.startBtn.addEventListener('click', startAnimation);
            elements.pauseBtn.addEventListener('click', pauseAnimation);
            elements.resetBtn.addEventListener('click', resetAnimation);
            elements.speedBtn.addEventListener('click', toggleSpeed);
            elements.speedRange.addEventListener('input', updateSpeedFromRange);
        }

        // 渲染序列元素
        function renderSequence(container, sequence, classes) {
            container.innerHTML = '';
            // 添加空元素表示起点
            const emptyItem = document.createElement('div');
            emptyItem.className = `${classes} bg-gray-100 text-gray-400`;
            emptyItem.textContent = '∅';
            container.appendChild(emptyItem);

            // 添加序列元素
            sequence.forEach((item, index) => {
                const element = document.createElement('div');
                element.className = classes;
                element.textContent = item;
                element.dataset.index = index;
                container.appendChild(element);
            });
        }

        // 生成坐标轴标签
        function generateAxisLabels() {
            // X轴标签 (序列A)
            elements.xAxisLabels.innerHTML = '';
            // 添加空元素标签
            addAxisLabel(elements.xAxisLabels, '∅', 0, true);
            // 添加序列A元素标签
            config.sequenceA.forEach((item, index) => {
                addAxisLabel(elements.xAxisLabels, item, index + 1, true);
            });

            // Y轴标签 (序列B)
            elements.yAxisLabels.innerHTML = '';
            // 添加空元素标签
            addAxisLabel(elements.yAxisLabels, '∅', 0, false);
            // 添加序列B元素标签
            config.sequenceB.forEach((item, index) => {
                addAxisLabel(elements.yAxisLabels, item, index + 1, false);
            });
        }

        // 添加坐标轴标签
        function addAxisLabel(container, text, index, isXAxis) {
            const label = document.createElement('div');
            label.className = `absolute flex items-center justify-center w-8 text-xs font-medium`;

            if (isXAxis) {
                label.style.bottom = `-${config.cellSize / 2 + 5}px`;
                label.style.left = `${index * config.cellSize}px`;
            } else {
                label.style.top = `${index * config.cellSize}px`;
                label.style.left = `-${config.cellSize / 2 + 5}px`;
                label.style.transform = 'translateX(-100%)';
            }

            label.textContent = text;
            container.appendChild(label);
        }

        // 预计算k线
        function precomputeKLines() {
            state.kLines = [];
            const maxX = config.sequenceA.length;
            const maxY = config.sequenceB.length;

            // 计算所有可能的k值范围
            const minK = -maxY;
            const maxK = maxX;

            // 为每个k值生成线上的点
            for (let k = minK; k <= maxK; k++) {
                const points = [];
                // 确定k线上的点范围
                let startX = Math.max(0, k);
                let startY = startX - k;

                // 确保y在有效范围内
                if (startY < 0) {
                    startY = 0;
                    startX = k + startY;
                }

                // 收集k线上的所有点
                let x = startX;
                let y = startY;
                while (x <= maxX && y <= maxY) {
                    points.push({x, y, k});
                    x++;
                    y++;
                }

                state.kLines.push({
                    k,
                    points,
                    element: null  // 稍后存储SVG元素引用
                });
            }
        }

        // 绘制k线
        function drawKLines() {
            // 清除现有k线
            document.querySelectorAll('.k-line').forEach(el => el.remove());

            // 绘制所有k线
            state.kLines.forEach(kLine => {
                if (kLine.points.length < 2) return;

                const pathData = kLine.points.map(point => {
                    const x = config.startOffset + point.x * config.cellSize;
                    const y = config.startOffset + point.y * config.cellSize;
                    return `${x},${y}`;
                }).join(' ');

                const polyline = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
                polyline.setAttribute('points', pathData);
                polyline.setAttribute('class', 'k-line');
                polyline.setAttribute('data-k', kLine.k);

                // 为k=0线设置特殊样式
                if (kLine.k === 0) {
                    polyline.setAttribute('stroke-width', '3');
                    polyline.setAttribute('opacity', '0.9');
                }

                elements.animationSvg.appendChild(polyline);
                kLine.element = polyline;
            });
        }

        // 开始动画
        function startAnimation() {
            if (state.isAnimating && !state.isPaused) return;

            state.isAnimating = true;
            state.isPaused = false;
            elements.startBtn.classList.add('hidden');
            elements.pauseBtn.classList.remove('hidden');

            // 如果是从头开始
            if (state.currentStep === 0) {
                state.path = [];
                // 添加起点
                addPointToPath(0, 0, '起点 (0,0)');
                state.currentStep = 1;
            }

            // 继续动画
            animateStep();
        }

        // 暂停动画
        function pauseAnimation() {
            if (!state.isAnimating) return;

            state.isPaused = true;
            elements.startBtn.classList.remove('hidden');
            elements.pauseBtn.classList.add('hidden');

            if (state.animationFrame) {
                cancelAnimationFrame(state.animationFrame);
                state.animationFrame = null;
            }
        }

        // 重置动画
        function resetAnimation() {
            pauseAnimation();

            // 清除路径
            document.querySelectorAll('.path-line, .path-point').forEach(el => el.remove());

            // 重置状态
            state.currentStep = 0;
            state.path = [];
            state.isAnimating = false;

            // 重置UI
            elements.currentStatus.textContent = '准备就绪，点击"开始动画"按钮开始演示';
            elements.startBtn.classList.remove('hidden');
            elements.pauseBtn.classList.add('hidden');

            // 重置k线样式
            state.kLines.forEach(kLine => {
                if (kLine.element) {
                    kLine.element.setAttribute('opacity', kLine.k === 0 ? '0.9' : '0.7');
                    kLine.element.setAttribute('stroke', '#EF4444');
                }
            });
        }

        // 切换动画速度
        function toggleSpeed() {
            const speeds = ['慢速', '中等', '快速', '极快'];
            const speedValues = [1500, 800, 400, 150];

            const currentIndex = speeds.indexOf(state.speedLevel);
            const nextIndex = (currentIndex + 1) % speeds.length;

            state.speedLevel = speeds[nextIndex];
            config.animationSpeed = speedValues[nextIndex];

            elements.speedText.textContent = state.speedLevel;
            elements.speedRange.value = config.animationSpeed;
        }

        // 从滑块更新速度
        function updateSpeedFromRange() {
            config.animationSpeed = parseInt(elements.speedRange.value);

            // 更新速度文本
            if (config.animationSpeed >= 1200) {
                state.speedLevel = '慢速';
            } else if (config.animationSpeed >= 600) {
                state.speedLevel = '中等';
            } else if (config.animationSpeed >= 300) {
                state.speedLevel = '快速';
            } else {
                state.speedLevel = '极快';
            }

            elements.speedText.textContent = state.speedLevel;
        }

        // 添加点到路径
        function addPointToPath(x, y, description) {
            state.path.push({x, y});

            // 绘制点
            const point = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            const svgX = config.startOffset + x * config.cellSize;
            const svgY = config.startOffset + y * config.cellSize;

            point.setAttribute('cx', svgX);
            point.setAttribute('cy', svgY);
            point.setAttribute('class', 'path-point');
            point.setAttribute('data-step', state.path.length - 1);

            // 如果是匹配点，添加特殊样式
            if (x > 0 && y > 0 &&
                config.sequenceA[x - 1] === config.sequenceB[y - 1]) {
                point.setAttribute('fill', '#3B82F6');
            }

            elements.animationSvg.appendChild(point);

            // 绘制线（如果不是第一个点）
            if (state.path.length > 1) {
                const prevPoint = state.path[state.path.length - 2];
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');

                line.setAttribute('x1', config.startOffset + prevPoint.x * config.cellSize);
                line.setAttribute('y1', config.startOffset + prevPoint.y * config.cellSize);
                line.setAttribute('x2', svgX);
                line.setAttribute('y2', svgY);
                line.setAttribute('class', 'path-line');
                line.setAttribute('data-step', state.path.length - 2);

                elements.animationSvg.appendChild(line);
            }

            // 更新状态文本
            elements.currentStatus.textContent =
                `步骤 ${state.path.length}: (x=${x}, y=${y}) - ${description} (k = ${x - y})`;

            // 高亮当前k线
            highlightCurrentKLine(x - y);
        }

        // 高亮当前k线
        function highlightCurrentKLine(k) {
            // 重置所有k线样式
            state.kLines.forEach(line => {
                if (line.element) {
                    line.element.setAttribute('opacity', line.k === 0 ? '0.9' : '0.7');
                    line.element.setAttribute('stroke', '#EF4444');
                }
            });

            // 高亮当前k线
            const currentKLine = state.kLines.find(line => line.k === k);
            if (currentKLine && currentKLine.element) {
                currentKLine.element.setAttribute('opacity', '1');
                currentKLine.element.setAttribute('stroke', '#F59E0B');
                currentKLine.element.setAttribute('stroke-width', '4');
            }
        }

        // 动画步骤
        function animateStep() {
            if (!state.isAnimating || state.isPaused) return;

            const currentPoint = state.path[state.path.length - 1];
            const x = currentPoint.x;
            const y = currentPoint.y;

            const maxX = config.sequenceA.length;
            const maxY = config.sequenceB.length;

            // 检查是否到达终点
            if (x === maxX && y === maxY) {
                elements.currentStatus.textContent =
                    `动画完成! 最短路径长度: ${state.path.length - 1} 步`;
                elements.startBtn.classList.remove('hidden');
                elements.pauseBtn.classList.add('hidden');
                state.isAnimating = false;
                return;
            }

            // 决定下一步移动
            let nextX, nextY, description;

            // 检查是否可以匹配（对角线移动）
            if (x < maxX && y < maxY &&
                config.sequenceA[x] === config.sequenceB[y]) {
                nextX = x + 1;
                nextY = y + 1;
                description = `匹配元素 "${config.sequenceA[x]}" (对角线移动)`;
            }
            // 否则决定是插入还是删除
            else if (x < maxX && (y >= maxY || x - y >= 0)) {
                // 删除操作（向右移动）
                nextX = x + 1;
                nextY = y;
                description = `删除元素 "${config.sequenceA[x]}" (向右移动)`;
            } else {
                // 插入操作（向下移动）
                nextX = x;
                nextY = y + 1;
                description = `插入元素 "${config.sequenceB[y]}" (向下移动)`;
            }

            // 添加下一个点到路径
            addPointToPath(nextX, nextY, description);
            state.currentStep++;

            // 安排下一步动画
            state.animationFrame = setTimeout(animateStep, config.animationSpeed);
        }

        // 页面加载完成后初始化
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
